---
layout: default
title:  "Models"
tag: main
---

# Models
## Defining accessors
Any class can be extended to add Dragonfly attachment functionality.

Let's say you have a model with methods `image_uid` and `image_uid=`
{% highlight ruby %}
class Photo
  attr_accessor :image_uid
end
{% endhighlight %}

Then you can add the Dragonfly attachment methods `image` and `image=` with
{% highlight ruby %}
class Photo
  extend Dragonfly::Model
  dragonfly_accessor :image
end
{% endhighlight %}

If the model class responds to `before_save` and `before_destroy` (like with ActiveRecord) then
the attachment will be stored on save (when changed) and destroyed on destroy.

To extend all ActiveRecord models, you can do
{% highlight ruby %}
ActiveRecord::Base.extend Dragonfly::Model
{% endhighlight %}

## Using the accessors

We can use the attribute much like other other model attributes:

{% highlight ruby %}
@photo = Photo.new

@photo.image = "\377???JFIF\000\..."             # can assign as a string...
@photo.image = File.new('path/to/my_image.png')  # ... or as a file...
@photo.image = some_tempfile                     # ... or as a tempfile...
@photo.image = Pathname.new('some/path.gif')     # ... or as a pathname...
@photo.image = @photo.band_photo                 # ... or as another Dragonfly attachment

@photo.image          # => <Dragonfly Attachment uid=nil, app=:default>

@photo.image = nil
@photo.image          # => nil
{% endhighlight %}

We can inspect properties of the attribute

{% highlight ruby %}
@photo.image.mime_type                      # => 'image/png'
@photo.image.size                           # => 63425 (size in bytes)
{% endhighlight %}

We can add add analyser methods (see [Analysers]({% post_url 0000-02-04-analysers %})), e.g.
the [Imagemagick]({% post_url 0000-01-05-imagemagick %}) plugin adds

{% highlight ruby %}
@photo.image.width                          # => 280
@photo.image.height                         # => 140
{% endhighlight %}

We can play around with the data

{% highlight ruby %}
@photo.image.data                           # => "\377???JFIF\000\..."
@photo.image.to_file('out.png')             # writes to file 'out.png' and returns a readable file object
@photo.image.to_file('out.png',
  :mode => 0600,
  :mkdirs => false
)
@photo.image.tempfile                       # => #<File:/var/folders/st/strHv74sH044JPabSiODz... a closed Tempfile object
@photo.image.file                           # => #<File:/var/folders/st/strHv74sH044JPabSiODz... a readable (open) File object
@photo.image.file do |f|                    # Yields an open file object, returns the return value of
  data = f.read(256)                        #  the block, and closes the file object
end
@photo.image.path                           # => '/var/folders/st/strHv74sH044JPabSiODz...' i.e. the path of the tempfile
{% endhighlight %}

We can add add processor methods (see [Processors]({% post_url 0000-02-03-processors %})), e.g.
the [Imagemagick]({% post_url 0000-01-05-imagemagick %}) plugin adds

{% highlight ruby %}
image = @photo.image.thumb('20x20')   # returns a 'Job' object
image.width                           # =>  20

image = @photo.image.encode('gif')
image.format                          # => 'gif'
{% endhighlight %}

## Assigning from a url
Dragonfly provides an accessor for assigning directly from a url:

{% highlight ruby %}
@photo.image_url = 'http://some.url/file.jpg'
{% endhighlight %}

You can put this in a form view, e.g. in rails erb:

{% highlight erb %}
<% form_for @photo, :html => {:multipart => true} do |f| %>
  ...
  <%= f.text_field :image_url %>
  ...
<% end %>
{% endhighlight %}

## Removing an attachment via a form
Normally unassignment of an attachment is done like any other attribute, by setting to nil

{% highlight ruby %}
@photo.image = nil
{% endhighlight %}

but this can't be done via a form - instead `remove_<attachment_name>` is provided, which can be used with a checkbox:

{% highlight erb %}
<%= f.check_box :remove_image %>
{% endhighlight %}

## Retaining across form redisplays
When a model fails validation, you don't normally want to have to upload your attachment again, so you can avoid having to do this by
including a hidden field in your form `retained_<attribute_name>`, e.g.

{% highlight erb %}
<% form_for @photo, :html => {:multipart => true} do |f| %>
  ...
  <%= f.file_field :image %>
  <%= f.hidden_field :retained_image %>
  ...
<% end %>
{% endhighlight %}

## Persisting
When the model is saved, a before_save callback persists the data to the Dragonfly app's configured datastore.
The uid column is then filled in.

{% highlight ruby %}
@photo = Photo.new

@photo.image_uid     # => nil

@photo.image = File.new('path/to/my_image.png')
@photo.image_uid     # => nil

@photo.save
@photo.image_uid     # => '2009/12/05/file.png' (some unique uid, used by the datastore)
{% endhighlight %}

URLs
----
Once the model is saved, we can get a url for the image which will be served by Dragonfly, and for its processed versions.

{% highlight ruby %}
@photo.image.url                           # => '/media/W1siZyIsInRleHQ...'
@photo.image.thumb('300x200#nw').url       # => '/media/WgsdoicjdslliZy...'
@photo.image.encode('gif').url             # => '/media/Wiflkpiubppndsh...'
{% endhighlight %}

Because the processing methods are lazy, no processing is actually done in the above code.

TODO: CARRY ON

Validations
-----------
`validates_presence_of` and `validates_size_of` work out of the box, and Dragonfly also provides `validates_property`.

    class Photo

      validates_presence_of :image
      validates_size_of :image, :maximum => 500.kilobytes

      validates_property :format, :of => :image, :in => [:jpeg, :png, :gif]
      # ..or..
      validates_property :mime_type, :of => :image, :as => 'image/jpeg', :case_sensitive => false

      validates_property :width, :of => :image, :in => (0..400), :message => "Ã© demais cara!"

      # ...
    end

The property argument of `validates_property` will generally be one of the registered analyser properties as described in {file:Analysers.md Analysers}.
However it would actually work for arbitrary properties, including those of non-dragonfly model attributes.

`validates_property` can also take a proc for the message, yielding the actual value and the model

    validates_property :width, :of => :image, :in => (0..400),
                               :message => proc{|actual, model| "Unlucky #{model.title} - was #{actual}" }

Name and extension
------------------
If the object assigned is a file, or responds to `original_filename` (as is the case with file uploads in Rails, etc.), then `name` will be set.

    @photo.image = File.new('path/to/my_image.png')

    @photo.image.name    # => 'my_image.png'
    @photo.image.ext     # => 'png'

Meta data
---------
You can store metadata along with the content data of your attachment:

    @photo.image = File.new('path/to/my_image.png')
    @photo.image.meta = {:taken => Date.yesterday}
    @photo.save!

    @photo.image.meta      # => {:model_class=>"Photo",
                                 #     :model_attachment=>:image,
                                 #     :taken=>Sat, 11 Sep 2010}

As you can see, a couple of things are added by the model. You can also access this directly on the {Dragonfly::Job Job} object.

    app.fetch(@photo.image_uid).meta     # => {:model_class=>"Photo", ...}

Meta data can be useful because at the time that Dragonfly serves content, it doesn't have access to your model, but it does
have access to the meta data that was stored alongside the content, so you could use it to provide custom response headers, etc.
(see {file:Configuration}).

Callbacks
---------
**after_assign**

`after_assign` can be used to do something every time content is assigned:

    class Person
      image_accessor :mugshot do
        after_assign{|a| a.process!(:rotate, 90) }  # 'a' is the attachment itself
      end
    end

    person.mugshot = Pathname.new('some/path.png')  # after_assign callback is called
    person.mugshot = nil                            # after_assign callback is NOT called

Inside the block, you can call methods on the model instance directly (`self` is the model):

    class Person
      image_accessor :mugshot do
        after_assign{|a| a.process!(:rotate, angle) }
      end

      def angle
        90
      end
    end

Alternatively you can pass in a symbol, corresponding to a model instance method:

    class Person
      image_accessor :mugshot do
        after_assign :rotate_it
      end

      def rotate_it
        mugshot.process!(:rotate, 90)
      end
    end

You can register more than one `after_assign` callback.

**after_unassign**

`after_unassign` is similar to `after_assign`, but is only called when the attachment is unassigned

    person.mugshot = Pathname.new('some/path.png')  # after_unassign callback is NOT called
    person.mugshot = nil                            # after_unassign callback is called

Up-front thumbnailing
---------------------
The best way to create different versions of content such as thumbnails is generally on-the-fly, however if you _must_
create another version _on-upload_, then you could create another accessor and automatically copy to it using `copy_to`.

    class Person
      image_accessor :mugshot do
        copy_to(:smaller_mugshot){|a| a.thumb('200x200#') }
      end
      image_accessor :smaller_mugshot
    end

    person.mugshot = Pathname.new('some/400x300/image.png')

    person.mugshot            # ---> 400x300 image
    person.smaller_mugshot    # ---> 200x200 image

In the above example you would need both a `mugshot_uid` field and a `smaller_mugshot_uid` field on your model.

Storage options
---------------
Some datastores take options when calling `store` - you can pass these through using `storage_xxx` methods, e.g.

**storage_path**

The {Dragonfly::DataStorage::FileDataStore FileDataStore} and {Dragonfly::DataStorage::S3DataStore S3DataStore} both
can take a `:path` option to specify where to store the content (which will also become the uid for that content)

    class Person
      image_accessor :mugshot do
        storage_path{ "some/path/#{first_name}/#{rand(100)}" }  # You can call model instance methods (like 'first_name') directly
      end
    end

or

    class Person
      image_accessor :mugshot do
        storage_path :path_for_mugshot
      end

      def path_for_mugshot
        "some/path/#{first_name}/#{rand(100)}"
      end
    end

or you can also yield the attachment itself

        storage_path{|a| "some/path/#{a.width}x#{a.height}.#{a.format}" }

**BEWARE!!!!** you must make sure the path (which will become the uid for the content) is unique and changes each time the content
is changed, otherwise you could have caching problems, as the generated urls will be the same for the same uid.

**BEWARE No. 2!!!!** using `id` in the `storage_path` won't generally work on create, because Dragonfly stores the content in a call to `before_save`,
at which point the `id` won't yet exist.

You can pass any options through to the datastore using `storage_xxx` methods, or all at once using `storage_opts`:

    class Person
      image_accessor :mugshot do
        storage_opts do |a|
          {
            :path => "some/path/#{id}/#{rand(100)}",
            :other => 'option'
          }
        end
      end
    end

"Magic" Attributes
------------------
An accessor like `image` only relies on the accessor `image_uid` to work.
However, in some cases you may want to record some other properties, whether it be for using in queries, or
for caching an attribute for performance reasons, etc.

For the properties `name`, `ext`, `size` and any of the registered analysis methods (e.g. `width`, etc. in the examples above),
this is done automatically for you, if the corresponding accessor exists.

For example - with ActiveRecord, given the migration:

    add_column :photos, :image_width, :integer

This will automatically be set when assigned:

    @photo.image = File.new('path/to/my_image.png')

    @photo.image_width  # => 280

They can be used to avoid retrieving data from the datastore for analysis

    @photo = Photo.first

    @photo.image.width     # => 280    - no need to retrieve data - takes it from `image_width`
   @photo.image.size      # => 134507 - but this needs to retrieve data from the data store, then analyse

Furthermore, any magic attributes you add a field for will be added to the meta data for that attachment (and so can be used when Dragonfly serves the content
for e.g. setting custom response headers based on that meta - see {file:Configuration}).

Custom Model
------------
The accessors only require that your model class implements `before_save`, `before_destroy` and `validates_each`
(if using validations), as well as of course the `..._uid` field for storing the datastore uid.

Here is an example of a minimal ActiveModel `Photo` model:

    class CustomModel::Base

      extend ActiveModel::Callbacks
      define_model_callbacks :save, :destroy

      include ActiveModel::Validations   # if needed

      def save
        _run_save_callbacks {
          # do some saving!
        }
      end

      def destroy
        _run_destroy_callbacks {
          # do some destroying!
        }
      end

    end

Define our `image_accessor` macro...

    app.define_macro(CustomModel::Base, :image_accessor)

...which is used by `Photo`:

    class Photo < CustomModel::Base

      def image_uid=
        # ...
      end

      def image_uid
        # ...
      end

      image_accessor :image

    end
